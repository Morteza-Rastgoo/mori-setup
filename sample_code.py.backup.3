"""
   Calculator class for basic arithmetic operations
   This class provides functions to perform basic mathematical operations, such as addition, subtraction, multiplication, division, square root, and exponentiation. It also includes functionality for storing and retrieving values using keys in a dictionary (memory).
   """

   from typing import Any, Union
   from functools import reduce
   from decimal import Decimal

   class Calculator:
       def __init__(self):
           self._memory = {}

       def _validate_numbers(self, a: Union[float, int], b: Union[float, int]) -> None:
           if not isinstance(a, (float, int)) or not isinstance(b, (float, int)):
               raise ValueError("Both inputs must be numbers")

       def _validate_operands(self, operands: tuple) -> None:
           for operand in operands:
               if not isinstance(operand, (float, int)):
                   raise TypeError("Only numbers are allowed as operands")

       def divide(self, a: Union[float, int], b: Union[float, int]) -> Union[float, str]:
           self._validate_numbers(a, b)
           if isinstance(b, int) and b == 0:
               raise ValueError("Cannot divide by zero")
           return super().divide(a, b)

       def add(self, *args: Union[float, int]) -> Union[float, str]:
           self._validate_operands((args))
           result = reduce((lambda x, y: x + y), args, 0)
           return result

       def subtract(self, *args: Union[float, int]) -> Union[float, str]:
           self._validate_operands((args))
           result = self.add(*([-i for i in args]))
           return result

       def multiply(self, *args: Union[float, int]) -> Union[float, str]:
           self._validate_operands((args))
           return reduce((lambda x, y: x * y), args, 1)

       def square_root(self, number: Union[float, int]) -> Union[float, Decimal]:
           if not isinstance(number, (float, int)):
               raise ValueError("Input must be a float or an integer")
           result = number ** 0.5 if number >= 0 else Decimal(-number ** 0.5)
           return result

       def power(self, base: Union[float, int], exponent: int) -> Union[float, str]:
           self._validate_numbers(base, exponent)
           if exponent < 0:
               raise ValueError("Exponent must be non-negative")
           return base ** exponent

       def store_and_recall(self, key: str, value: Union[float, int]) -> None:
           self._memory[key] = value

       def recall(self, key: str) -> Union[float, int]:
           if key not in self._memory:
               raise KeyError("No such memory key")
           return self._memory[key]